import React from "react";import {  DndContext,  DragEndEvent,  DragOverEvent,  PointerSensor,  closestCenter,  useSensor,  useSensors} from "@dnd-kit/core";import { SortableContext, verticalListSortingStrategy } from "@dnd-kit/sortable";import { arrayMove } from "@dnd-kit/sortable";import type { AppData, Item, ItemType, Screen, WeekKey } from "./types";import { TopNav } from "./ui/components/TopNav";import { WeekScreen } from "./ui/components/WeekScreen";import { MonthScreen } from "./ui/components/MonthScreen";import { ItemRow } from "./ui/components/ItemRow";import { loadAppData, makeEmptyWeek, saveAppData } from "./storage";import { weekKeyFromDate } from "./date";import { isContainerId, parseDayFromContainerId, getContainerIdForItemGlobal } from "./dnd";function uid() {  return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 9)}`;}export default function App() {  const initialWeekKey = weekKeyFromDate(new Date());  const [screen, setScreen] = React.useState<Screen>("week");  const [weekKey, setWeekKey] = React.useState<WeekKey>(initialWeekKey);  const [data, setData] = React.useState<AppData>(() => loadAppData(initialWeekKey));  // Ensure current week exists  React.useEffect(() => {    setData((prev) => {      if (prev.weeks[weekKey]) return prev;      return { ...prev, weeks: { ...prev.weeks, [weekKey]: makeEmptyWeek(weekKey) } };    });  }, [weekKey]);  // Persist all changes  React.useEffect(() => {    saveAppData(data);  }, [data]);  const week = data.weeks[weekKey] ?? makeEmptyWeek(weekKey);  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 6 } }));  function addInboxItem(type: ItemType, text: string) {    const item: Item = {      id: uid(),      type,      text,      completed: type === "todo" ? false : undefined,      createdAt: Date.now()    };    setData((prev) => ({ ...prev, inbox: [item, ...prev.inbox] }));  }  function addDayItem(dateISO: string, type: ItemType, text: string) {    const item: Item = {      id: uid(),      type,      text,      completed: type === "todo" ? false : undefined,      createdAt: Date.now()    };    setData((prev) => {      const wk = weekKeyFromDate(new Date(dateISO + "T00:00:00"));      const w = prev.weeks[wk] ?? makeEmptyWeek(wk);      const dayItems = w.days[dateISO] ?? [];      const nextWeek = { ...w, days: { ...w.days, [dateISO]: [item, ...dayItems] } };      return { ...prev, weeks: { ...prev.weeks, [wk]: nextWeek } };    });  }  function toggleComplete(itemId: string) {    setData((prev) => {      // inbox      const inboxIdx = prev.inbox.findIndex((i) => i.id === itemId);      if (inboxIdx >= 0) {        const it = prev.inbox[inboxIdx];        if (it.type !== "todo") return prev;        const updated: Item = { ...it, completed: !it.completed };        const inbox = prev.inbox.slice();        inbox[inboxIdx] = updated;        return { ...prev, inbox };      }      // days across all weeks      const nextWeeks: AppData["weeks"] = { ...prev.weeks };      for (const [wk, w] of Object.entries(nextWeeks)) {        let changed = false;        const nextDays: typeof w.days = { ...w.days };        for (const [dateISO, items] of Object.entries(nextDays)) {          const idx = items.findIndex((i) => i.id === itemId);          if (idx >= 0) {            const it = items[idx];            if (it.type !== "todo") return prev;            const updated: Item = { ...it, completed: !it.completed };            const copy = items.slice();            copy[idx] = updated;            nextDays[dateISO] = copy;            changed = true;            break;          }        }        if (changed) {          nextWeeks[wk] = { ...w, days: nextDays };          return { ...prev, weeks: nextWeeks };        }      }      return prev;    });  }  function setWeekNotes(text: string) {    setData((prev) => {      const w = prev.weeks[weekKey] ?? makeEmptyWeek(weekKey);      const nextWeek = { ...w, notesText: text };      return { ...prev, weeks: { ...prev.weeks, [weekKey]: nextWeek } };    });  }  function prevWeek() {    const d = new Date(weekKey + "T00:00:00");    d.setDate(d.getDate() - 7);    setWeekKey(weekKeyFromDate(d));  }  function nextWeek() {    const d = new Date(weekKey + "T00:00:00");    d.setDate(d.getDate() + 7);    setWeekKey(weekKeyFromDate(d));  }  function openWeekForDay(dayISO: string) {    const wk = weekKeyFromDate(new Date(dayISO + "T00:00:00"));    setWeekKey(wk);    setScreen("week");  }  function renderItem(item: Item) {    return <ItemRow item={item} onToggleComplete={toggleComplete} />;  }  function renderDraggableList(items: Item[], containerId: string) {    return (      <div className="list" data-container={containerId}>        {items.map((item) => (          <ItemRow key={item.id} item={item} onToggleComplete={toggleComplete} />        ))}      </div>    );  }  // ---------- DnD (global across all weeks) ----------  function onDragOver(event: DragOverEvent) {    const { active, over } = event;    if (!over) return;    const activeId = String(active.id);    const overId = String(over.id);    const from = isContainerId(activeId) ? activeId : getContainerIdForItemGlobal(activeId, data);    const to = isContainerId(overId) ? overId : getContainerIdForItemGlobal(overId, data);    if (!from || !to || from === to) return;    setData((prev) => {      let moving: Item | null = null;      let nextInbox = prev.inbox.slice();      let nextWeeks = { ...prev.weeks };      const removeFromList = (list: Item[]) => {        const idx = list.findIndex((i) => i.id === activeId);        if (idx === -1) return { list, removed: null as Item | null };        const copy = list.slice();        const [removed] = copy.splice(idx, 1);        return { list: copy, removed };      };      // Remove from source      if (from === "inbox") {        const r = removeFromList(nextInbox);        nextInbox = r.list;        moving = r.removed;      } else {        const fromDay = parseDayFromContainerId(from);        if (!fromDay) return prev;        const fromWeekKey = weekKeyFromDate(new Date(fromDay + "T00:00:00"));        const fromWeek = nextWeeks[fromWeekKey] ?? makeEmptyWeek(fromWeekKey);        const r = removeFromList(fromWeek.days[fromDay] ?? []);        const updatedFromWeek = {          ...fromWeek,          days: { ...fromWeek.days, [fromDay]: r.list }        };        nextWeeks[fromWeekKey] = updatedFromWeek;        moving = r.removed;      }      if (!moving) return prev;      const insertIntoList = (list: Item[]) => {        // if hovering over container, prepend; if hovering over item, insert before it        if (isContainerId(overId)) return [moving!, ...list];        const idx = list.findIndex((i) => i.id === overId);        if (idx === -1) return [moving!, ...list];        const copy = list.slice();        copy.splice(idx, 0, moving!);        return copy;      };      // Insert into destination      if (to === "inbox") {        nextInbox = insertIntoList(nextInbox);      } else {        const toDay = parseDayFromContainerId(to);        if (!toDay) return prev;        const toWeekKey = weekKeyFromDate(new Date(toDay + "T00:00:00"));        const toWeek = nextWeeks[toWeekKey] ?? makeEmptyWeek(toWeekKey);        const updatedToWeek = {          ...toWeek,          days: { ...toWeek.days, [toDay]: insertIntoList(toWeek.days[toDay] ?? []) }        };        nextWeeks[toWeekKey] = updatedToWeek;      }      return { ...prev, inbox: nextInbox, weeks: nextWeeks };    });  }  function onDragEnd(event: DragEndEvent) {    const { active, over } = event;    if (!over) return;    const activeId = String(active.id);    const overId = String(over.id);    const from = getContainerIdForItemGlobal(activeId, data);    const to = isContainerId(overId) ? overId : getContainerIdForItemGlobal(overId, data);    if (!from || !to) return;    if (from !== to) return; // reorder only within same container    setData((prev) => {      const reorder = (arr: Item[]) => {        const oldIndex = arr.findIndex((i) => i.id === activeId);        const newIndex = arr.findIndex((i) => i.id === overId);        if (oldIndex < 0 || newIndex < 0) return arr;        return arrayMove(arr, oldIndex, newIndex);      };      if (from === "inbox") {        return { ...prev, inbox: reorder(prev.inbox) };      }      const dayISO = parseDayFromContainerId(from);      if (!dayISO) return prev;      const wk = weekKeyFromDate(new Date(dayISO + "T00:00:00"));      const w = prev.weeks[wk] ?? makeEmptyWeek(wk);      const nextWeek = {        ...w,        days: { ...w.days, [dayISO]: reorder(w.days[dayISO] ?? []) }      };      return { ...prev, weeks: { ...prev.weeks, [wk]: nextWeek } };    });  }  // ---------- end DnD ----------  return (    <div className="container">      <TopNav screen={screen} onChange={setScreen} />      <DndContext sensors={sensors} collisionDetection={closestCenter} onDragOver={onDragOver} onDragEnd={onDragEnd}>        {screen === "week" ? (          <WeekScreen            weekKey={weekKey}            week={week}            inbox={data.inbox}            onPrevWeek={prevWeek}            onNextWeek={nextWeek}            onAddToDay={addDayItem}            onAddToInbox={addInboxItem}            onToggleComplete={toggleComplete}            onNotesChange={setWeekNotes}            renderDraggableList={renderDraggableList}            renderItem={renderItem}          />        ) : (          <MonthScreen data={data} renderItem={renderItem} onPickDay={openWeekForDay} />        )}      </DndContext>      <div className="small" style={{ marginTop: 14 }}>        Storage: local only (localStorage). No backend.      </div>    </div>  );}